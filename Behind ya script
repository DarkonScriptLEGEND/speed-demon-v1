--// Updated teleport function with tween & yellow particles + anti-cheat bypass tweaks
local TweenService = game:GetService("TweenService")

local function teleportSmoothlyTo(pos)
	local hrp = getHRP(LocalPlayer)
	if not hrp then return end
	
	-- Add tiny random offset to position (Â±1 stud) to reduce pattern detection
	local offset = Vector3.new(
		math.random(-10,10)/10,
		math.random(-5,5)/10,
		math.random(-10,10)/10
	)
	local targetPos = pos + offset

	-- Create yellow sparkle particle effect
	local particle = Instance.new("ParticleEmitter")
	particle.Color = ColorSequence.new(Color3.fromRGB(255, 255, 100))
	particle.LightEmission = 0.7
	particle.Size = NumberSequence.new(0.5)
	particle.Texture = "rbxassetid://258128463" -- yellow sparkle texture
	particle.Rate = 80
	particle.Speed = NumberRange.new(1, 3)
	particle.Lifetime = NumberRange.new(0.3, 0.5)
	particle.Parent = hrp
	Debris:AddItem(particle, 0.6)

	-- Tween hrp.CFrame to targetPos smoothly over 0.15 seconds
	local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Linear)
	local tween = TweenService:Create(hrp, tweenInfo, {CFrame = CFrame.new(targetPos)})
	tween:Play()

	-- Play teleport sound
	teleportSound:Play()

	-- Wait tween to finish before next action (with tiny random jitter delay to avoid strict timing patterns)
	tween.Completed:Wait()
	task.wait(math.random(10, 20) / 100)  -- wait 0.1 to 0.2 seconds randomly
end

--// Replace teleportBehindPlayer to use teleportSmoothlyTo

local function teleportBehindPlayer(target)
	if not target or not target.Character then return end
	local hrp = getHRP(LocalPlayer)
	local targetHRP = getHRP(target)
	if not hrp or not targetHRP then return end

	local lookVector = targetHRP.CFrame.LookVector
	local desiredPos = targetHRP.Position - lookVector * 45
	
	-- Check safe position, else fallback
	if not isPositionSafe(desiredPos) then
		desiredPos = getFurthestSafePosition()
	end

	teleportSmoothlyTo(desiredPos)
	playTeleportAnimation()
	showFloatingText("Poof!", Color3.fromRGB(255, 255, 100), 1)
end

--// Update circleLoop to use teleportSmoothlyTo and add anti-cheat timing offsets

local function circleLoop()
	if cooldownTeleport then return end
	circleLoopActive = true
	circleLoopToggleBtn.Text = "Circle Loop: ON"

	local hrp = getHRP(LocalPlayer)
	local pos = hrp.Position
	local center = pos

	local mapSize = Workspace:GetExtentsSize() / 2 - Vector3.new(5, 0, 5)
	local radius = math.min(50, mapSize.X - math.abs(center.X), mapSize.Z - math.abs(center.Z))

	local angle = 0
	while circleLoopActive do
		if cooldownTeleport then break end
		local x = center.X + math.cos(angle) * radius
		local z = center.Z + math.sin(angle) * radius
		local newPos = Vector3.new(x, center.Y, z)
		if isPositionSafe(newPos) then
			teleportSmoothlyTo(newPos)
		end
		angle = angle + math.rad(30)
		task.wait(0.12 + math.random(5, 15) / 100) -- add random delay 0.12-0.27s for anti-cheat bypass
	end
	circleLoopToggleBtn.Text = "Circle Loop: OFF"
	circleLoopActive = false
end

--// Update stuck detection to use tween as well

RunService.Heartbeat:Connect(function()
	if behindYaActive then
		local target, dist = getNearestPlayer(85)
		local hrp = getHRP(LocalPlayer)
		if not hrp then return end
		
		if dist and dist <= 35 and not cooldownSelfDestruct and not selfDestructActive then
			selfDestruct()
		end

		if target and dist and dist <= 85 and not cooldownTeleport and not selfDestructActive then
			teleportBehindPlayer(target)
			lastSafePosition = hrp.Position
			startTeleportCooldown()
		end

		if circleLoopActive then
			local near, nearDist = getNearestPlayer(195)
			if near and nearDist <= 195 then
				-- circleLoop will handle teleporting
			else
				stopCircleLoop()
			end
		end

		-- Stuck or under map detection (gentler with tween teleport)
		if lastSafePosition then
			local pos = hrp.Position
			if pos.Y < 0 or (pos - lastSafePosition).Magnitude > 55 then
				-- Tween teleport out instead of instant snap
				teleportSmoothlyTo(lastSafePosition)
				showFloatingText("Bypassed Anti Cheat!", Color3.fromRGB(0, 255, 0), 3)
				bypassSound:Play()
				task.wait(0.3)
			end
		end
	end
end)
