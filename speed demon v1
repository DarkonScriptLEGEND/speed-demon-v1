-- Services
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
local Humanoid = Character:WaitForChild("Humanoid")

-- Create ScreenGui
local ScreenGui = Instance.new("ScreenGui", game.CoreGui)
ScreenGui.Name = "TeleportWhenNearGui"
ScreenGui.ResetOnSpawn = false

-- Create toggle button
local ToggleButton = Instance.new("TextButton")
ToggleButton.Size = UDim2.new(0, 200, 0, 50)
ToggleButton.Position = UDim2.new(0.5, -100, 0.5, -25)
ToggleButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
ToggleButton.TextColor3 = Color3.new(1, 1, 1)
ToggleButton.Text = "Teleport When Near: OFF"
ToggleButton.Parent = ScreenGui

-- State variables
local teleportOn = false
local isTeleporting = false

-- Helper: Get map bounds (5 studs inset)
local function getMapBounds()
	local minX, minY, minZ = math.huge, math.huge, math.huge
	local maxX, maxY, maxZ = -math.huge, -math.huge, -math.huge

	for _, part in pairs(workspace:GetDescendants()) do
		if part:IsA("BasePart") then
			local pos = part.Position
			minX = math.min(minX, pos.X - part.Size.X/2)
			maxX = math.max(maxX, pos.X + part.Size.X/2)
			minY = math.min(minY, pos.Y - part.Size.Y/2)
			maxY = math.max(maxY, pos.Y + part.Size.Y/2)
			minZ = math.min(minZ, pos.Z - part.Size.Z/2)
			maxZ = math.max(maxZ, pos.Z + part.Size.Z/2)
		end
	end
	-- Inset by 5 studs to avoid void/out of bounds
	return
		minX + 5, maxX - 5,
		minY + 5, maxY - 5,
		minZ + 5, maxZ - 5
end

local minX, maxX, minY, maxY, minZ, maxZ = getMapBounds()

-- Find the furthest safe location within bounds on 75 stud radius circle
local function findFurthestSafeLocation()
	local furthestPos = HumanoidRootPart.Position
	local furthestDist = 0
	local radius = 75

	for i = 0, 360, 10 do
		local rad = math.rad(i)
		local candidatePos = HumanoidRootPart.Position + Vector3.new(math.cos(rad), 0, math.sin(rad)) * radius

		-- Clamp candidate within map bounds
		candidatePos = Vector3.new(
			math.clamp(candidatePos.X, minX, maxX),
			math.clamp(candidatePos.Y, minY, maxY),
			math.clamp(candidatePos.Z, minZ, maxZ)
		)

		-- Check ground under candidate to avoid void
		local ray = Ray.new(candidatePos + Vector3.new(0, 10, 0), Vector3.new(0, -50, 0))
		local part = workspace:FindPartOnRay(ray, Character)
		if part and part:IsA("BasePart") then
			local dist = (candidatePos - HumanoidRootPart.Position).Magnitude
			if dist > furthestDist then
				furthestDist = dist
				furthestPos = candidatePos
			end
		end
	end
	return furthestPos
end

-- Teleport loop function
local function teleportLoop()
	if isTeleporting then return end
	isTeleporting = true

	for i = 1, 35 do
		local targetPos = findFurthestSafeLocation()
		HumanoidRootPart.CFrame = CFrame.new(targetPos)
		task.wait(0.3)
	end

	local originalSpeed = Humanoid.WalkSpeed
	Humanoid.WalkSpeed = 52
	task.delay(15, function()
		Humanoid.WalkSpeed = originalSpeed
	end)

	isTeleporting = false
end

-- Monitor players and toggle teleport when near
task.spawn(function()
	while true do
		if teleportOn and not isTeleporting then
			for _, player in pairs(Players:GetPlayers()) do
				if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
					local dist = (player.Character.HumanoidRootPart.Position - HumanoidRootPart.Position).Magnitude
					if dist <= 250 then
						teleportLoop()
						break
					end
				end
			end
		end
		task.wait(0.5)
	end
end)

-- Toggle button logic
ToggleButton.MouseButton1Click:Connect(function()
	teleportOn = not teleportOn
	if teleportOn then
		ToggleButton.Text = "Teleport When Near: ON"
	else
		ToggleButton.Text = "Teleport When Near: OFF"
	end
end)

-- Update references on respawn
LocalPlayer.CharacterAdded:Connect(function(char)
	Character = char
	HumanoidRootPart = char:WaitForChild("HumanoidRootPart")
	Humanoid = char:WaitForChild("Humanoid")
end)
